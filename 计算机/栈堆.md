# 内存分配中的栈与堆

本文讨论的栈堆是指计算机程序内存分配中栈堆概念，而不是数据结构中的栈堆。

## 内存分配中的栈堆概念

![img](https://pic002.cnblogs.com/images/2012/78090/2012032700061112.gif)



进程内的内存组织示意如图



栈（stack) —— 由编译器自定分配释放，存放函数的参数值，局部变量值等，其操作方式类似与数据结构中的栈。栈的分配运算内置于处理器的指令集中，运行效率所以很快，但是分配的内存有限。

堆（heap) —— 一般由程序员手动申请分配以及释放，如C语言中使用malloc函数来申请内存空间，使用free函数来释放内存空间。如果没有及时释放的话，就会可能导致内存泄露错误。



## 栈堆差异

### 分配方式

如概念节所诉，栈由编译器自动分配，堆由程序员手动分配



### 碎片问题

对于堆来讲 频繁的分配与释放会导致内存空间的不连续，从而导致大量碎片，导致程序性能下降。栈则不存在这个问题



### 分配效率

栈是机器系统提供的数据结构，计算机在底层会对栈提供支持，栈的分配运算内置于处理器的指令集中，运行效率很快，



堆分配由编程语言提供实现。申请一块空间需要遍历空闲内存地址链表，直到找到第一个空间大于所需的节点，再将其从空间内存链表中删除，最后分配給程序。另外，由于找到的堆节点大小不一定正好等于所需空间大小，系统会自动建多余的部分重新放入空闲内存链表，故堆的分配效率要低上不少。



### 申请大小

堆设计上一般比栈大，原因有一下几点

- 堆通常是进程内共用的，栈通常是线程独占的，一个进程包含多个线程，所以堆就有必要比栈大了。
- Stack 的最顶端一般会留存在 CPU registers 和 cache 中。遇到频繁但是层次不多的函数调用，可以利用高速 cache。大块的内存会破坏这种优化。
- C的栈在x86-64上是直接绑定到CPU指令的，实现上极其精简，因此它与堆不同，没有动态增长、动态缩小的功能，一旦分配出来就会永远占用相应的空间。每个线程都会占用独立的栈空间，这样对于线程数很多的进程来说，如果栈空间分配得过多，就会很浪费内存空间。相反，堆空间可以一开始分配得很小，然后不停向上增长，释放相应的空间之后还可以归还给操作系统，因此适合处理比较大的空间。





## 验证栈向下分配

C语言代码示例



错误的验证方法

```c
#include <stdio.h>

int main() {
    int a = 0;
    int b = 1;
    printf("%X\n%X\n", &a, &b);
}

// output
// E8A49410
// E8A49414
```

a,b变量代码中的先后声明顺序不能代表其入栈顺序



正确的验证方式

```c
#include <stdio.h>

int main() {
    char out = 1;
    fn(&out);

    return 0;
}

void fn(char * out) {
    char inner = 1;
    printf("%X\n%X\n", out, &inner);
}

// output
// 346C4BF7
// 346C4BD7
```



可以看出栈变量的地址是向下增长的，即后入栈的变量内存地址会更小。



## 为什么栈向下增长，堆向上增长

栈堆在内存组织上连续的，栈向下增长，堆向上增长是因为

> **这样设计可以使得堆和栈能够充分利用空闲的地址空间。**如果栈向上涨的话，我们就必须得指定栈和堆的一个严格分界线，但这个分界线怎么确定呢？平均分？但是有的程序使用的堆空间比较多，而有的程序使用的栈空间比较多。所以就可能出现这种情况：一个程序因为栈溢出而崩溃的时候，其实它还有大量闲置的堆空间呢，但是我们却无法使用这些闲置的堆空间。所以呢，最好的办法就是让堆和栈一个向上涨，一个向下涨，这样它们就可以最大程度地共用这块剩余的地址空间，达到利用率的最大化！！

ref

- [堆和栈的理解和区别，C语言堆和栈完全攻略](http://c.biancheng.net/c/stack/)

- [为什么栈相对于堆很小？](https://www.zhihu.com/question/59238963)

- [用代码判断栈的增长方向](https://gaomf.cn/2017/09/28/Detect_Stack_Direction/)
- [进程中堆栈向下增长的原因](https://www.cnblogs.com/virusolf/p/4892334.html)

