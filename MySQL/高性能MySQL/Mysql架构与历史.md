# Mysql架构与历史





## 读写锁

读锁/共享锁：读锁是共享的，互不阻塞。

写锁/排他锁：写锁阻塞其它读写锁



### 锁粒度

粒度小，并发度高,  但是锁会耗费额外开销；

粒度大，安全性高。



Mysql存储引擎自行实现锁策略以及锁粒度，但是Mysql服务器本身支持表锁，必要时忽略存储引擎锁。



#### 表锁

写入操作时锁住全表，阻塞其他线程的读写操作；读锁不阻塞。



#### 行级锁

只对读写的行锁定



### 死锁

死锁是指两个或者多个事务在同一资源上互相占用，请请求锁定对方占用的资源，从而实现死循环。



InnoDB处理办法：

检测有死锁发生时，将持有最少行级排它锁的事务进行回滚。



### 显示、隐式锁

隐式锁不需要用户指定，MySQL会自行加解锁；



显示上锁：

- Mysql服务器支持的`LOCK TABLE` & `UNLOCK TABLE`
- InnoDB
    - `SELECT ... FOR UPDATE`
    - `SELECT ... LOCK IN SHART LOCK`

### MVCC

MVCC（ 多版本并发控制）可以认为是行级锁的变种，才很多情况下避免了对行的加锁却达到隔离级别的要求，没有统一实现标准，不同数据库有不同实现。InnoDB 的MVCC 只在 REPEATED READ 和 READ COMMITED 隔离级别下工作。



InnoDB实现

主要原理：

在每行记录上保存两个隐藏的列，分别保存行创建时间以及行的过期时间（删除时间），这里的时间不是实际时间值，而是系统版本号（每开启一个事务，系统版本自动递增）。

事务内的查询则加上这两列的筛选来控制隔离性，具体筛选行为略。



## 事务



### ACID



- 原子性（atomicity）—— 一个事务视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部执行，要么全部不执行（失败回滚）
- 一致性（consistency) —— 数据库总是从一个一致性的状态转换到另外一个一致性的状态。这个概念很模糊，参考[如何理解数据库事务中的一致性的概念？](https://www.zhihu.com/question/31346392)

- 隔离性（isolation）—— 一个事务所做的修改在最终提交前，对其他事务是不可见的（这个不可见不是绝对的，参考隔离级别）
- 持久性（durability）—— 一旦事务提交，则所做的修改就会永久保存到数据库中，即使此时系统崩溃，修改的数据`1也不会丢失



Mysql默认采用自动提交模式，即如不显式开始一个事务，则每个查询都当作一个事务执行，该行为可更改。



对于在混用了支持与非支持事务的表执行是事务正常情况下没问题，不过如果需要回滚的话，非事务表上的变更无法撤销。



## 存储引擎



查看表信息

`SHOW TABLE STATUS LIKE '<table name>'`



简单来说如果不是非得使用其他存储引擎的特性，选择默认的InnoDB就好



### InnoDB

特性

- 支持事务
- 自动崩溃恢复
- 外键支持
- 热备份
- 行级锁

### Myisam

- 全文索引
- 压缩
- 空间函数
- 表锁

### Federated

- 支持跨服务器数据库合作（如跨库join）

### Memory

- 内存数据库，不需要磁盘IO故效率高，但是重启后数据清除（结构保留）







